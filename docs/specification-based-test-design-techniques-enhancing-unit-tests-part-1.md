# 增强单元测试的基于规范的测试设计技术第 1 部分

> 原文：<https://simpleprogrammer.com/specification-based-test-design-techniques-enhancing-unit-tests-part-1/>

大多数开发人员的主要目标通常是实现 100%的代码覆盖率，如果他们编写任何单元测试的话。在这篇测试设计指南文章中，我将向您展示如何使用**基于规范的测试设计技术**来通过您的单元测试覆盖更多的需求。

我见过很多[单元测试](https://simpleprogrammer.com/2010/10/15/the-purpose-of-unit-testing/)，在那些由程序员开发的单元测试中，大多数并没有完全覆盖需求。考虑一下你如何写你的测试。您是否从应用程序的规范文档中提取测试输入？如果不是，你应该是！在本文的最后，您将知道如何通过两种特定的技术来提供一种基于规范设计测试用例的方法:**等价划分**和**边界值分析**。

## 非基于规范的测试

我写了一个简单的类来解释文章的思想。

这个静态实用程序的主要目标是返回 Sofia 运输线路一个月的订阅价格。在实用程序中，客户应该提交他们的年龄。结果价格随年龄而变化。

0

5

18

65 <=年龄< = 122–价格= 5 lv

在我看来，大多数开发人员倾向于基于他们的代码编写测试。他们首先阅读规范，编写代码，然后基于代码本身设计测试。他们的目标是实现 **100%代码覆盖率**，而不是 **100% *规格*覆盖率**。当我想到这一趋势时，我问自己:**“如果测试是基于可能已经包含错误的代码，为什么还要编写会失败的测试呢？”**

为了达到 100%的代码覆盖率，只需要 7 次测试。对于测试示例，我将使用 **NUnit** ,因为它具有方便的属性(如果您想更多地使用 NUnit，可以查看 John 的[生产力工具评论](https://simpleprogrammer.com/2014/07/08/developer-productivity-tool-review-teleriks-devcraft/)。

**随机？真的吗？**你可能会感到震惊，但是很多开发人员倾向于在他们的测试中使用这种技术。我第一次看到类似上面的代码时，我在*至少*了 5 分钟。在测试中使用随机数据会导致不可靠的测试结果。测试生成的一些值可能是绿色的，但其他值可能是红色的。

### 基于代码的测试用例

**【Random(min:1，max: 5，count:1)】**然后 **Price = 0** ，先覆盖 else if。

**【随机(最少:6，最多:18，计数:1)】**然后**价格= 20** ，覆盖第二个否则如果。

**【随机(最小值:19，最大值:64，计数:1)】**然后**价格= 40** ，覆盖第三个。

**【随机(最小值:65，最大值:122，计数:1)】**然后**价格= 5** ，覆盖高级价格。

**AgeInput= "invalid"** ，当用户传递一个非整数值时，验证第一个异常场景。

**AgeInput= "0"** ，覆盖第二次防御检查。

**AgeInput= "1000"** ，使测试通过关于最大年龄的最后一次验证检查。

在仅仅七个测试案例中，我们已经成功实现了 100%的代码覆盖率。然而，很有可能这些测试用例将**而不是**捕捉到回归错误，例如，如果有人改变了“<”、>、> =”或“< =”条件操作符中的一个。此外，这种编写测试的方法并不能保证代码是正确的。如果测试是基于错误的代码，它们不会帮助我们交付更好的无问题软件。这就是**基于规格的测试设计技术可以帮助我们的地方**。

## 基于规格说明的测试:基于等价划分

首先，让我回顾一下基于规格的测试是什么意思。

> 这是一种测试方法，其中测试用例是基于测试目标和从需求中导出的测试条件**来设计的，例如，执行特定功能或探测非功能属性(如可靠性或可用性)的测试。**

等价划分的主要目标是**将测试用例的数量减少到必要的最小值**并且**选择正确的测试用例来覆盖所有可能的场景**。

### 等价划分假设

> 划分后的集合称为等价划分或等价类。然后，我们从每个分区中只选择一个值进行测试。该技术背后的假设是**如果一个分区中的一个条件/值通过，所有其他条件/值也将通过**。同样，**如果一个分区中的一个条件失败，该分区中的所有其他条件也将失败**。

测试 1-10 这样的小输入范围很容易，但测试 2-10000 这样的范围很难。**等价划分**帮助我们遵循 **[七个测试原则](http://software-testing.pl/en/basics-of-software-testing/seven-testing-principles-by-istqb)** 之一:

> **不可能进行详尽的测试**:不可能测试所有东西，包括输入和前提条件的所有组合。我们可以使用风险和优先级来集中我们的测试工作，而不是进行详尽的测试。例如:在一个应用程序中，一个屏幕上有 15 个输入字段，每个字段有 5 个可能的值。要测试所有有效的组合，您需要 30，517，578，125 (515)次测试。项目时间表不太可能允许这么多的测试，这*非常不太可能。评估和管理风险是任何项目中测试最重要的活动和原因之一。*

有时候，编写 1 到 10 个测试来覆盖 1 到 10 个测试集可能更便宜，但是大多数情况下，为更大的测试集编写 100，000 或数百万个测试是不合适的。所以我们可以使用**基于规格说明的测试设计技术**来**减少测试用例的数量到必要的最小值**。

如果我必须为生产编写前面提到的代码，并且测试它，我可能会使用 **[测试驱动开发](https://simpleprogrammer.com/2014/03/27/views-test-driven-development/)** 。然后，我将根据规范要求设计测试场景。

如你所见，在我的测试中，我使用了 [**NUnit** TestCase 属性](http://www.nunit.org/index.php?p=testCase&r=2.5)。一旦执行了这个方法，将根据通过属性提供的值执行七个测试。第一个值表示 ageInput 第二个是预期价格。

测试用例是使用等价划分得到的。测试用例的数量没有增加。然而，主要的区别是测试是基于规范需求的，而不是基于代码本身。而且，它们是在代码之前写的**。**

![Equivalence-Partitioning Table Partitions Example](img/266a6dab16c13356fcf52f62973e527f.png)

从表中可以看出，有七个等价分区:四个有效分区和三个无效分区。我用表中最后一行的值来覆盖它们。

### 要记住的等价划分错误

虽然这种技术相对简单，但人们在应用它时确实会犯一些常见的错误。

1.  The different subsets cannot have any member in common. If a value is present in two partitions, you cannot define how it should behave in the different cases.
2.  所有子集都不能为空。如果您不能从一个集合中选择一个测试值，它对测试没有价值。

## 基于规格的测试:基于边界值分析

**那么什么是边界值分析呢？**

> 它是一种黑盒测试设计技术，其中测试用例是基于边界值设计的。但是，什么是边界值呢？
> 
> **边界值**是输入值或输出值，其在等价划分的边缘上或在边缘任一侧的最小增量距离处，例如，范围的最小值或最大值。

这是一种细化等价划分的技术。**边界值分析**是**等价划分**的下一部分。其中，测试用例被选择在等价类的边缘。覆盖标准是每个边界值，不管是有效的还是无效的，都必须在至少一个测试中表示出来。

主要区别在于每个等价类中至少有两个边界值。所以我们会有两倍的测试。

所有等价类都有边界值吗？

不，绝对不是。边界值分析仅适用于当等价类的成员被排序时。

### 有多少个边界值？

对于应该存在多少边界值，有两种观点。大多数人认为，从等价划分的每条边上只能得出两个值。因此，在以下条件下， **0 <年龄> 6** ，对于第一个边缘，边界值将是 **0，1** ，对于第二个限制 **5，6** 。

在他的书《软件系统测试和质量保证》中，Boris Beizer 解释了另一种选择:每个边界有三个值，每个边和它的每个邻居都被算作一个测试值。对于前面的条件，0 <年龄> 6，对于 0 测试值将是-1，0 和 1。对于 6，测试值将是 6 本身、5 和 7。

在我的职业生涯中，我尝试了两种方法，我相信使用第二种方法，我能够发现更多的错误。因此，我鼓励您使用 Boris Beizer 的技术，而不管测试用例数量的增加。

### 使用边界值分析的测试

使用基于边界值分析规范的测试设计技术，我在实际代码的编写过程之前，仅基于规范要求，为 transportsubscriptioncardpricalculator 创建了总共 20 个测试。



![field](img/80e20af2756924eab1c7427e22a4c116.png)

[](https://simpleprogrammer.com/wp-content/uploads/2015/08/field.jpg)为了达到 100%的边界值分析覆盖率，你只需要前 16 个测试。但是，我又增加了四个测试，因为有时候即使测试值属于公共等价划分，也不代表它们会产生相同的结果。所以，我用 null，string 测试了 CalculateSubscriptionPrice。Empty，int。Max + 1 和 int。最小–1。

### 基于需求的边界值

1.  0 < Age <= 5 – Left Edge: -1, 0, 1 Right Edge: 4, 5, 6
2.  5

3.  18

4.  65 <=年龄< = 122–左边缘:64，65，66 右边缘:121，122，123

### 在哪里可以找到边界值？

一个类的边界值通常是基于规范需求的，它解释了系统在不同的用例中应该如何表现。然而，这些值通常不会在任何现有的规范文档中提及。在这种情况下，如果不可能更新需求，您可以使用测试 oracles。

> 测试 Oracle:确定预期结果的来源，以便与被测软件的实际结果进行比较。oracle 可以是现有的系统(作为基准)、用户手册或个人的专业知识，但它不应该是代码。

例如，如果您开发了一个计算器应用程序，并且没有关于它在某些情况下应该如何表现的完整规范，您可以使用 Microsoft Windows 内置计算器来测试 oracle。

## 结论



![3dballs](img/babdc40b4aef6a22cfabaedd92a8d3c6.png)

[](https://simpleprogrammer.com/wp-content/uploads/2015/08/3dballs.jpg)你可以使用基于规格的测试设计策略来编写覆盖所有需求的绝对最小单元测试。等价划分和边界值分析可以将您从基于潜在错误代码设计测试的邪恶实践中拯救出来，从而产生通过但不正确的测试。用你对系统的了解，你的智慧和直觉去尝试更多的测试值，因为没有完美的测试设计技术。