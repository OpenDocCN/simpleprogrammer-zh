# 没有一个阶级是孤岛

> 原文：<https://simpleprogrammer.com/no-class-is-an-island/>

我发现任何框架的最大挑战之一是让它自我发现。

通常很难构建一个框架或 API，使得该框架的用户能够容易地知道存在什么以及何时使用什么。

难以编写一个好的框架的主要原因之一是，许多开发人员倾向于创建与框架中的其他类非常松散地连接的类，他们打算与这些类进行交互。



![104004A.TIF](img/98f88d363b5f9647642a6f58331c6378.png "104004A.TIF")



## 定义岛屿

当您创建一系列类时，您是明确地计划让这些类相互依赖，还是试图以一种独立的方式设计它们？

这个问题带出了[松耦合紧内聚](https://simpleprogrammer.com/2010/11/04/back-to-basics-cohesion-and-coupling-part-1/)的老话题。

我认为一个类是一个岛，如果它是松散耦合的，但也是松散内聚的。

作为孤岛的类是这样的类，它以很少的依赖或很弱的依赖做自己的事情。

想象一下一个 *CurrencyConverter* 类。

这个类被设计用来将一种货币的金额转换成另一种货币。

有几种方法可以为这个类创建 API。

这是其中之一:

现在这似乎是一个非常合理的 API，但是这里有一个问题。问题是如果你有一个实现了 *ICurrency* 的类，你没有任何好的方法知道这个类的存在。

如果我们不做别的，这个阶级还不如根本不存在。这是一个岛。

它可以看到它需要使用的类，但是可以受益于 *CurrencyConverter* 的类不知道它的存在。

使用 *ICurrency* 实现的开发人员没有好办法知道这个转换是否存在。最有可能的是，开发人员最终会编写自己的货币转换器实现。

重复！不好！

## 日期和时间链接

你会经常在代码库和框架中看到这种情况。您将有许多不同的实用程序文件夹或类来帮助进行日期和时间操作。

问题是，没有人真正知道这些实用程序类的存在，所以每个人最终都会重写你的代码库的所有功能，这样你就一团糟了。

看一看您自己的项目，看看您是否能找到所有处理日期、时间或货币的实用程序类。现在检查一下这些实用程序类是否在它们可能在的地方被使用。他们很可能不是。

## 建造桥梁

我们需要在岛上建一座桥，这样每个人都可以享受美丽的海滩。

如果没有人知道它的存在，就没有必要构建你的奇妙的 *CurrencyConverter* ，对吗？

那么我们如何解决这个问题呢？

这绝对是一个棘手的问题。

我发现的最好的方法是将依赖类绑定到它的依赖上。

**没错，我就是提倡循环依赖！**

不要惊慌，没那么糟。你所要做的就是确保你的 *ICurrency* 接口引用了 *CurrencyConverter* ，这样使用 *ICurrency* 的人就会知道它的存在。

现在有很多方法可以做到这一点。有些涉及使用基本货币类，有些涉及为货币类创建不同的静态构造函数。

我将向你们展示一个非常简单的例子，来说明我的观点。

真的就这么简单。你现在已经建立了一个到这个岛的桥，它是 *CurrencyConverter* 。

现在，当开发人员键入“.”时在一个 *ICurrency* 实现中，他们会看到一个使用你的转换器的 convert 方法，他们会知道它的存在！欢乐！

再说一次，有很多方法可以建造这座桥。我的意图不是在这里辩论它们。

重点是…建桥！

## 但这是一种循环依赖，这是不好的

真的吗？

在你的代码库中，这比 5 个货币转换的实现还要糟糕？

我们在这里真正做的是建立一个非常紧密结合的东西。这未必是一件坏事。

我们不想做的是将货币转换与我们的计费系统代码紧密耦合。我们不希望我们的 *CurrencyConverter* 使用一些建筑系统类。

## 进一步应用这个想法

这里的基本思想是，每当你创建一个新的类时，你应该考虑别人如何知道它的存在。

如果这个类是独立存在的，并且将来可能会有用，那么你必须做些什么来把它绑定到它的依赖项上。

如果开发人员不能通过智能感知通过其他类发现你的类，那么你的类可能不存在。

每当我创建一个类时，我都试着想两件事:

1.  有人会如何使用这个类
2.  他们怎么知道这个班级的存在