# 基础到基础:什么是依赖倒置？是国际奥委会吗？第二部分

> 原文:[https://simple programmer . com/basic-to-basics-what-is-dependency-inversion-is-it-IOC-part-2/](https://simpleprogrammer.com/basic-to-basics-what-is-dependency-inversion-is-it-ioc-part-2/)

在我之前关于依赖倒置的文章中，我谈到了什么是依赖倒置，并给出了一些现实世界中的例子。

这篇文章将更多地关注细节以及它与代码的关系。

## 回到你的代码…

现在让我们看一个代码例子，看看依赖倒置是如何帮助我们的。假设您正在创建一个高级模块，用于解析日志文件并将一些基本信息存储到数据库中。

在这种情况下，您希望能够处理来自许多不同来源的几个不同的日志文件，并将它们共享的一些公共数据写入数据库。解决这种问题的一种方法是让你的模块根据日志文件包含的数据和格式以及它的位置来处理每一种日志文件。使用这种方法，在您的模块中，您可以根据各个日志文件呈现给您的界面来处理各种日志文件。(当我在这里使用接口时，我不是在谈论语言结构，而是我们如何与某物交互的概念。)

使用这种方法，在我们的模块中，我们可能会有一个 switch 语句或一系列 if-else 语句，根据我们正在处理的日志文件的类型，将我们引向不同的代码路径。对于一个日志文件，我们可以在磁盘上打开一个文件，读取一行，然后根据某个分隔符拆分该行。另一种可能是我们打开一个数据库连接并读取一些行。

问题是日志文件定义了我们的高级代码必须使用的接口。它们实际上“控制着”我们的代码，因为它们规定了我们的代码必须符合的行为。

我们可以颠倒这种控制，并通过指定我们处理的日志文件必须符合的接口来颠倒依赖性。我们甚至不需要使用语言级别的界面。

我们可以简单地创建一个名为 *LogFile* 的数据类，作为我们模块的输入。任何想使用我们模块的人都必须首先将他们的文件转换成我们的格式。

我们还可以创建一个 *ILogFileSource* 接口，类可以实现该接口来包含解析来自不同来源的日志文件的逻辑。我们的模块将依赖于 *ILogFileSource* ，并指定它需要什么样的方法和数据来解析日志文件，而不是相反。

这里的关键点是，我们的高层模块应该控制低层模块需要遵守的接口(非语言构造类),而不是受每个低层模块接口的支配。

考虑这个问题的一种方式是，较低级别的模块向较高级别的模块提供服务。较高层模块指定该服务的接口，较低层模块提供该服务。



![room-service](img/d07b0ac00abac3a8e7ef9bdbfc23e569.png "room-service")



在这个例子中我想指出的一点是，我们知道会有不止一个日志文件源。如果我们正在编写一个日志文件解析模块，该模块只对一个源起作用，那么可能不值得尝试反转这种依赖性，因为我们看不到这样做的任何好处。对于我们来说，用一个源代码尽可能清晰地写出代码并不难，一旦我们有了额外的源代码，就可以重构它来颠倒依赖关系。

仅仅因为你可以颠倒依赖关系并不意味着你应该这样做。

在这种情况下，由于我们总是写入数据库，我不觉得有什么特别的需要来改变我们对写出日志文件的依赖。然而，将所有与数据库交互的代码封装到一个地方确实有一些价值，但那是另一篇文章的内容。

## 注意我们还没有谈到单元测试

你会发现依赖反转和控制反转的问题与单元测试没有任何关系。

简单地将一个接口放在一个类的顶部，并将其注入到另一个类中，可能有助于单元测试，但这不一定会反转控制或依赖。

我想用日志解析的例子来说明我的观点。假设我们已经创建了日志解析器，用一个 switch 语句来处理每种类型的日志文件，现在我们想对代码进行单元测试。

我们没有理由不能创建 *IDatabaseLogFile* 、 *ICSVFileSystemLogFile* 、 *IEventLogLogFile* 和*IAnNotReallyDoingIoCLogFile*，将它们作为依赖项传递到我们的 *LogFileParser* 的构造函数中，然后编写我们的单元测试，通过每个的模拟。

这当然是一个极端的例子，但重点是将一个接口强加到一个类上并不是 IoC 所做的。

我们不应该试图实现这个原则来使编写单元测试变得更容易。难写的单元测试应该给我们这样的提示:

*   我们班想做的太多了
*   我们的类有许多不同的依赖项
*   我们班需要大量的设备来做作业
*   我们的类就像另一个类，只对不同的输入做同样的事情

所有这些提示都告诉我们，我们可能想要反转控制和反转依赖来改进类的整体设计，而不是因为这样更容易测试。(虽然它也应该使测试更容易。)

## 好的，好的，那么依赖反转和控制反转是一样的还是什么？

简而言之:是的。

这取决于你所说的控制是什么意思。有三种基本的“控制”可以反转。

1.  界面的控制。(这两个系统，模块，或者说类，是如何相互交互和交换数据的？)
2.  流量的控制。(程序的流程是由什么控制的？当我们从过程驱动转向事件驱动时，就会发生这种控制倒置。)
3.  依赖关系创建和绑定的控制。(这是 IoC 容器所做的那种反转控制。这种倒置是将对依赖关系的实际创建和选择的控制传递给第三方，该第三方对所涉及的其他两方都是中立的。)

这 3 个中的每一个都是依赖倒置的特定形式，甚至可能涉及多种被倒置的依赖。

因此，当有人说“控制反转”时，你应该在想“这里反转的是什么控制？”

依赖性倒置是我们在设计软件时使用的一个原则。

控制反转是一种应用于此的特定模式。

大多数人只把控制反转看作上面的#3，反转依赖创建和绑定的控制。这是 IoC 容器和依赖注入扎根的地方。

## 我们能从中学到什么？

我的目标是，我们不再用依赖注入来自动分组控制反转和依赖反转的概念。

我们已经了解到，依赖倒置是一个核心原则，它指导着从它派生出来的许多其他实践。

每当我们应用一个模式时，我们应该寻找它所依赖的核心原则，以及它在帮助我们解决什么问题。

有了对依赖反转和控制反转的基本理解，我们就有了查看依赖注入和更好地理解它试图解决什么具体问题的先决知识。(我将在另一篇文章中讨论这个问题。)