# 重构然后更改遗留代码

> 原文：<https://simpleprogrammer.com/refactor-then-change-legacy-code/>

昨天我想起了一个非常重要的步骤，在处理遗留代码时，我忘记了这个步骤。第一步。重构。



![legacy code](img/4f84b4c1bd224a76ccddc72f055a3dc6.png "legacy")



使用遗留代码可能具有挑战性。尤其是那些由不知道自己在做什么的人编写，然后被不关心自己在做什么的人修改了 10 次的代码。(这可能是 90%的遗留代码。)

我倾向于直接在我自己的类中实现我的 clean 特性，我会将它集成到遗留代码中，并将相关的逻辑移到我自己的类中。

## 好方法

让我看看能否总结一下我的步骤:

1.  为我正在实现的新功能创建失败的单元测试。
2.  创建新的类，它只包含该功能的逻辑，但我知道它与一些遗留代码重叠。
3.  重复，直到我的功能正常工作。
4.  将我的类的使用集成到遗留代码中。
5.  开始将分担我的类的责任的遗留代码部分移到我的类中。
6.  重构剩余的遗留代码。

## 更好的方法

我觉得这些步骤没那么糟糕。但是有一个问题，通过在开头增加“重构遗留代码”这一步就很容易解决了。问题是清楚地知道遗留代码的责任。在这种情况下，大多数时候遗留代码有多重责任。当您完成了新功能的实现并清理了代码后，您应该会在一个责任中拥有几个类( [SRP](http://en.wikipedia.org/wiki/Single_responsibility_principle) )。

问题是写得不好的遗留代码往往隐藏了它正在做的所有事情。重构代码首先让您能够更好地理解代码中可能隐藏的职责。它还允许您更好地看到逻辑的真实结构，这有助于清楚地识别您想要取出来放置新逻辑的类。

因此，向遗留代码添加功能的一组更好的步骤是:

1.  尽可能清晰地重构遗留代码。
2.  为我正在实现的新功能创建失败的单元测试。
3.  创建新的类，它只包含该功能的逻辑，但我知道它与一些遗留代码重叠。
4.  重复，直到我的功能正常工作。
5.  将我的类的使用集成到遗留代码中。
6.  开始将分担我的类的责任的遗留代码部分移到我的类中。
7.  重构剩余的遗留代码。