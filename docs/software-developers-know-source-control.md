# 关于源代码管理，软件开发人员应该知道什么

> 原文：<https://simpleprogrammer.com/software-developers-know-source-control/>

我一直对源代码管理有一种爱恨交加的关系。

在我的软件开发生涯中，我很快认识到，不管喜欢还是讨厌，了解源代码控制是成为一名程序员非常重要的一部分。

当时我在惠普和另外一个开发人员一起做一个小项目。

我们正在开发一个名为“食蚁兽”的程序，用来自动测试惠普打印机。

一个可爱的早晨，我愉快地编码，并决定我需要获得代码的最新更新。

我正在为我正在构建的一个新特性处理几个文件，我的队友 Brian 刚刚签入了一些更改。

不想用过时的代码工作，我把最新的变化下载到我的机器上。

我构建了应用程序并运行它，以确保一切正常。

应用程序启动了，但我的电脑上发生了一些奇怪的事情。

硬盘指示灯一直在闪烁。

我能听到机械传动装置正在努力工作的呼呼声。

它在做什么，但是是什么呢？

![](img/48493fba55a9445796591095f2511e58.png)

几分钟后，我的屏幕上弹出了一个错误对话框，接着是可怕的蓝屏死机。

我的电脑自动重启，我收到了“非系统盘错误”的信息

嗯，好吧。通常这意味着你的硬盘已经崩溃。

我联系了一下。

他们看了看我的系统，确认确实有问题。可能是硬盘损坏了。

他们重新映像了我的机器，第二天我就有了全新的 Windows 安装。

我花了一整天重新安装和重新配置我的开发环境。

最后，我把一切都整理好了，所以我下载了应用程序的最新源代码，以及我在我的分支上所做的更改，并启动了应用程序。

我的硬盘指示灯又开始闪烁了。

我试图堕胎，但为时已晚。

几秒钟后，迎接我的是重新启动和一个熟悉的信息…“非系统磁盘错误。”

WTF？

发生了什么事？

至少可以说我很生气。

最后我想到了。

我走到布赖恩的办公桌前，看了看他提交的修改。

他将 C++头文件中的一个变量初始化为值“C:\temp”

他这样做是为了让他写的函数能够工作，让应用程序扫描临时文件，并在启动时删除它们。

我在同一个 C++头文件中做了一个更改，但是我还没有合并我的更改。

因此，当我下载他的最新代码时，我没有得到变量设置为“C:\temp”的最新头文件，但我得到了扫描“tempFileLocation”并删除那里所有内容的代码。

因为我的变量没有初始化，所以它默认为“C:\”—我电脑的根目录。

每次我启动这个应用程序，它都会递归删除我电脑上的所有文件。

源代码管理是如此有趣。

## 什么是源代码管理？

源代码控制，或者有时叫做版本控制，是一种跟踪不同版本的文件和一个软件项目的源代码，以及协调多个开发人员工作的方法，这些开发人员可能都在处理相同的文件集。

源代码控制和源代码控制系统有许多版本和实现，但是它们都有相同的目标**帮助你最好地管理你的软件开发项目的源代码。**

## 为什么重要？

![](img/132892a96c03c545a3f32e89af0f72ef.png)

当我刚开始作为一名软件开发人员工作时，有很多团队不使用源代码控制。

我参与过多个项目，其中价值数百万美元的系统的源代码存放在共享的网络文件夹或软盘上。

天知道有多少依赖这个版本的源代码控制的公司——有时被称为 sneaker net——在有人错误地删除了磁盘或共享文件夹的内容时破产了。

源代码控制如此重要的一个主要原因是因为它缓解了这个问题。

使用源代码控制系统的团队不太可能“丢失”他们的代码。

源代码控制为您提供了一个地方来签入您的代码并保持它的安全，这样它就不会被随意删除，并且它允许您跟踪更改，这样如果您不小心删除了代码的某个部分或犯了一个巨大的错误，您就可以返回并修复它。

你曾经在你的电脑上保存了一个文档的多个副本，标题中有不同的日期，这样你就可以在需要的时候返回到一个更早的版本。

这就是源代码管理可以为应用程序中的所有代码做的事情。

但是源代码控制不仅仅是确保你不会丢失你的源代码。

你可以定期备份数据来避免这个问题。

源代码控制也**帮助你能够协调多个开发人员在一个代码库中处理同一组文件。**

如果没有源代码管理来帮助管理开发人员所做的不同更改，开发人员很容易覆盖彼此的更改，或者被迫等到其他人完成编辑文件后才能编辑它。

一个好的源代码控制系统将允许你同时处理甚至相同的文件，然后将修改合并在一起。

源代码控制还解决了在软件应用程序的代码库的多个版本上工作的问题。

假设您有一个已经发布给客户的应用程序，其中有一些错误需要修复，但同时您正在为应用程序的下一版本开发一些新功能，而这些新功能还没有完全准备好。

如果可以有多个版本的代码不是很好吗？

例如，一个版本可能是当前发布的版本，您可以在其中进行错误修复，而另一个版本可能是您开发新功能的地方。

如果您可以将错误修复应用到包含新特性的代码版本中，这不是很好吗？

源代码控制给了你这样做的能力。

## 源代码管理基础

![](img/aef10f970af1a213d046ade1b7883b5f.png)

关于源代码控制有相当多的东西需要了解——**你当然不会仅仅通过阅读它而成为一名专家**——但是你可以学习基础知识。

在下一节中，我将向您简要介绍源代码管理的基础知识，然后介绍一些最常见的源代码管理技术，这样您至少可以理解源代码管理通常是如何工作的。

## 仓库

几乎所有源代码控制系统的关键概念之一是存储库的概念——它基本上是存储所有代码的地方。

当您处理源代码时，您将从存储库中获取代码，对其进行处理，并签入您的更改。

其他开发商可能也在做同样的事情。

存储库是所有代码汇集的地方，也是代码技术上“生存”的地方

不同的源代码控制系统对什么是存储库有不同的概念，甚至可能有本地存储库，但是最终，对于任何代码库，必须有一个中心位置或存储库作为记录系统。

## 签出代码

当您想要获得可以修改的代码的本地版本时，您需要从资源库中签出代码。

旧的源代码控制系统实际上让你签出代码并锁定文件，所以只有你能编辑它们。

如今，大多数源代码控制系统都允许您“签出”代码，方法是将代码的本地副本下载到您自己的机器或本地存储库中。

这个签出的代码是你的本地副本，你对它所做的更改只能在你的机器上或你的本地存储库中进行。

只有当您将代码“签入”或合并到中央存储库时，其他开发人员才能看到您的更改。

通常，当您使用源代码管理时，您会签出代码库的本地副本，实现新功能，或者对代码进行其他更改，然后当您完成时，您会将代码签入并处理多个开发人员处理相同代码部分时可能出现的任何冲突。

## 修订

源代码管理系统有一个版本的概念，即包含在源代码管理中的文件的先前版本。

例如，如果我们有一个名为 foo.bar 的文件，我先创建了它，然后你修改了它，然后我又修改了它，那么源代码控制库将包含三个不同版本的 foo.bar。

为什么这很重要？

有几个原因。

首先，假设我把 foo.bar 搞砸了，你想恢复到我修改之前的版本。

因为文件在源代码控制中，**你可以简单地回复到先前的版本或者签出版本**，假装我的修改从来不存在。

您还可以**查看修订历史，并比较文件随时间的变化，通过查看每个修订中发生了什么变化以及谁做出了这些变化，来了解文件是如何演变的**。

(我喜欢称之为相互指责。)

## 分支

源代码控制中最容易被误解的领域之一是分支——或者更确切地说是[如何正确使用分支](https://simpleprogrammer.com/2010/06/04/simple-branching-strategy-part-1-back-to-basics/)。

不过，这个概念相当简单。

大多数源代码控制系统允许你创建一个现有代码库的分支，以创建一个可以独立于其父代码库的新代码库。

等等，什么？我记得你说过这很简单，约翰。

好，把你的代码想象成一棵树。

你已经有了主干，在某个时候，你可能会从主干上分出多个分支。

这在现实中是什么样子的？

假设您有一个正在开发的软件版本，并且您准备将该版本发布给客户，并将其命名为版本 1，但是…您仍然希望继续开发版本 2 的新功能。

问题是——即使你是一个很棒的程序员——你知道在你发布给客户的版本 1 中，至少会有一些你必须修复的错误。

然而，当你给他们版本 1 的错误修复时，你不希望开始向他们提供版本 2 的特性。(您计划以后向他们收取升级到版本 2 的费用。)

你是做什么的？

简单。你将代码分支。

一旦您准备好发布版本 1，您将创建一个新的分支，而不是仅仅发布主干中的内容。你称这个分支为“版本 1”

然后，您可以在版本 1 分支上进行错误修复，并在主干上实现您的新特性。

只有一个问题…

如果您也想将这些 bug 修复程序放到主干中，该怎么办呢？

## 合并

![](img/761f9a6e10183664d6013501e06150ab.png)

看我布置得多漂亮。

你的问题的解决方案是合并。

你可能会问，什么是合并？

听起来确实如此。

您将把一个代码行的更改合并到另一个代码行中。

在上面的小软件示例中，我们简单地使用了源代码控制系统的合并特性，将版本 1 的分支变更合并到主干中。

合并允许我们在从主干分支之后，将我们在版本 1 分支上所做的所有更改，合并到主干中。

合并将只进行一个方向，所以我们将所有的变更从版本 1 分支转移到主干中，但是我们在主干中工作的新特性都不会转移到版本 1 分支中。

正如我们所愿。

世界上一切都很好，很平静，直到我们真正尝试合并，我们发现我们已经…

## 冲突

F$%^！，d%&$！这是什么 s&$*？！

*(奇怪的是，我自己在这本书里打屎都没问题，但是在一句话里掉三个“强”字，以 F-bomb 开头，似乎有点不合适。)*

当开发人员试图进行简单、直接的过程，将一些简单的更改合并回主干时，经常会说这种话。

大多数情况下，这发生在周五晚上 5:00，那时你只想快速合并然后离开那里。

你开始合并，穿上外套，给你的朋友发短信，告诉他们你将在哪里和他们见面，度过一个放松的夜晚，喝点酒，吃顿晚餐，然后迅速瞥一眼你的屏幕，看到:

*“冲突(内容):合并 simplefile.java 冲突*

*自动合并失败；修复冲突，然后提交结果。"*

或者其他类似的垃圾。

几个小时过去了，你盯着一个文件中的一串“<<<<> > > >”符号，试图弄清楚这一切。

我不打算撒谎；合并冲突是…一个婊子。

大多数时候，一个好的源代码控制系统会尝试自动将一个文件的一部分中的简单更改合并到另一个文件中，这一切都神奇地工作着。

但是……经常，你在一个分支上的一个文件中做了一个改变，一些愚蠢的白痴开发人员也在同一行上的同一个文件中做了一个改变——因为他是个白痴——并且需要人工干预。

计算机无法知道哪个更改应该覆盖另一个，或者两个更改是否应该以某种方式包含在内，或者是否有其他方法来解决冲突，所以这取决于您。

你的周五之夜被毁了。

**解决合并冲突和合并的复杂性可能是另外一本书**本身，所以我不打算在这里深究细节。

现在知道合并基本上是如何工作的就足够了，当它不工作时，冲突存在，必须手动解决，不要在周五晚上准备离开之前做“简单的合并真的很快”。

## 技术

源代码管理有一个相当长的有点有趣的历史，这里不打算讨论，因为我在有趣的部分撒了谎。

足以说明的是**源代码控制系统是从在 USB 驱动器上传递源代码，到有策略地复制源代码控制的整个文件夹并将它们重命名为 V1，再到我们今天拥有的相当复杂的系统。**

许多战争都是在源代码控制领域进行的，最终两个主要派别取得了胜利:集中式源代码控制和分布式。

中央集权更古老。它没有太多的“华丽”，但它更容易理解，而且很管用。

CVS 和 Subversion 是集中式源代码控制的两个例子。

分布式是更新的。在大多数人眼里，它可能更闪亮，也更复杂，但更多的人在使用它。

Git 和 Mercurial 是分布式源代码控制的两个例子。

## 集中式源代码控制

有了集中式源代码控制，**您就有了一个存储库，它存在于一个中央服务器上**,所有开发代码的开发人员利用它来获得他们需要的文件的副本，并签入他们对文件所做的更改。

每个开发人员都有一个源代码控制客户端，用于管理从中央存储库中签入和签出代码。

文件的所有版本历史和修订都存储在中央存储库中。

使用集中式源代码管理的典型工作流可能如下所示:

1.  从存储库中更新我正在处理的代码行的本地副本。
2.  做出我的改变。
3.  将我的更改提交到中央存储库(并处理任何冲突)。

## 分布式源代码控制(DVCS)

使用分布式源代码控制的最大区别是**每个开发人员在他们自己的机器上都有整个存储库的完整副本。**

一些真正酷的潮人喜欢说，这意味着“没有中央存储库，伙计。就好像我们都有自己的软件版本，没有哪个版本比其他版本更好。”

这是完全错误的。

是的，理论上这是可能的，但是如果你没有某种记录系统，你怎么在多个开发者之间发布代码和协调一个项目呢？

这是不可能的。

如果你认为它会，你可能应该开始你自己的乌托邦或邪教什么的。

实际情况是，是的，每个开发人员都有他们自己的完整的存储库副本，但是您仍然**利用存储库的某个中心版本作为记录系统**或者项目的主存储库。

当您在一个分布式源代码控制系统中工作时，您只需在本地工作，做您在中央存储系统中会做的一切事情，除了它发生在本地。

本质上，这意味着您不必通过网络传输那么多文件，并且可以在一段时间内断开连接工作。

然而，最终，你必须得到其他人已经做出的改变，你必须把你美丽、珍贵的改变发送到这个世界，让他们自己保护自己。

你通过推拉来做到这一点。

使用 DVCS，您可以将更改下拉到您的本地存储库，并且可以将您所做的更改推送到主存储库或您想要的任何其他存储库——包括您的时髦、分散、每个存储库都是平等的朋友。

## 最流行的源代码控制系统的快速概述

![](img/0f2d7dee1c8e8ce99c5a9faec30e97c8.png)

如果你将来在读这本书，这个列表可能会改变。

总是有新的源代码管理热点。

但是，现在，在写这本书的时候，我想我应该给你一个简单的介绍，关于你可能在野外看到的最常见的源代码控制系统。

注意:很简短。

## CVS

不，这不是药店。这是源代码控制。

它被称为 CVS 或并发版本系统。(我从来没叫过全名；实际上我得去查一下。)

这是什么？

嗯，我知道当我这么说的时候有些人会生气，但是在我看来这是颠覆的前兆。

CVS 是一个集中的源代码控制系统，它相当健壮。

它非常强大，但是有点慢。

大多数使用 CVS 的组织最终都转向了 Subversion，但是 CVS 仍然以稍微不同的方式处理一些事情，一些人更喜欢这些不同。

例如，标记和分支以及回滚提交在 CVS 中的处理方式不同。

CVS 狂热者会告诉你 CVS 做得对，Subversion 做得不对。

我真的不在乎，所以我只是点点头，因为我不喜欢被叉子刺伤。

## 破坏

偏差警报。

Subversion 可能是我最熟悉的源代码控制系统。

我教授过如何以纯粹图形化的方式使用它的课程，我写过关于使用它的分支和合并策略的[博客文章，我还为使用该技术的大型开发团队管理过 SVN 服务器、存储库和源代码控制策略。](https://simpleprogrammer.com/2010/06/04/simple-branching-strategy-part-1-back-to-basics/)

这是否意味着我是一个超级粉丝，认为其他一切都很糟糕？

不，不是真的。

就集中式源代码控制系统而言，[我认为 Subversion 是最好的](http://amzn.to/2bRXc4U)，但它肯定有它的缺点。

不过，总的来说，它完成了工作，而且相当容易使用，所以我喜欢它。

## 饭桶

![](img/0fa7505051536b8399bd2abf0167557a.png)

**Git 基本上已经成为了源码控制的代名词。**

今天问一个 25 岁以下的开发人员什么是源代码管理，他或她很可能会说，“什么，你是说 Git？”

这是有充分理由的。

Git 是……嗯……非常棒。

真的是。

就源代码控制软件而言， [Git 几乎做了你想要的一切](http://amzn.to/2bw6Gpv)。

它非常强大。

基本原理相当简单。

它快速、高效、通用。

Git 甚至有一家非常大的公司支持 Git 项目的开源和托管，名为 [GitHub](http://github.com) 。

如果你还没有看过的话，绝对值得一试。

## 水银的

Mercurial 有点像 Git 的邪恶孪生兄弟。

有人说 Git 就像 MacGyver，Mercurial 就像詹姆斯·邦德。

我不太清楚他们在谈论什么——或者他们在抽什么——但我有点明白了。

Mercurial 可以被描述为比 Git 更优雅和更优雅。

相同的基本思想——它们都是分布式源代码控制。

相同的基本功能和特性。

但是，根据我的经验，Mercurial 更容易使用和理解，而 Git 更神秘，但是有更多的方法来组合和破解东西。

所以，本质上我只是通过与 g it 的比较来描述 Mercurial。

嗯，那就只好这样了。

如果你两个都用，你就知道为什么了。

这有点像那种毫无意义的宗教战争。

## 还有别的吗？

不，不是真的。

主要的源代码控制系统差不多就是这四个，Git 占据了很大的市场份额。

是的，有些人正在使用其他的东西，并愉快地跟着哼唱，但是这种情况非常少见。

好了，现在你有了源代码控制的基础。

记得尽早承诺，并且经常承诺。

哦，请使用有意义的提交消息。

* * *



![](img/3d4c6b4621e942e8d37ef4e991c7d3a2.png)

