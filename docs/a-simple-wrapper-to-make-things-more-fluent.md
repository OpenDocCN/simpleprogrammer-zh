# 一个简单的包装器让事情更流畅

> 原文:[https://simple programmer . com/a-simple-wrapper-to-make-things-more-fluent/](https://simpleprogrammer.com/a-simple-wrapper-to-make-things-more-fluent/)

这篇文章实际上是我的上一篇文章的延续，我的上一篇文章是关于使用一种采取*动作*的方法来解决横切关注点，比如日志记录，而不必进行全面的 AOP 实现。

有人在评论中提到，并不清楚最终代码会发生什么。我倾向于同意这一点:

**logon error(_ 电饭煲。厨师)；**

…不是很清楚。

真的，我发现这段代码有两个问题。

1.  目前还不清楚这将会发生什么，也不清楚 *LogOnError* 或 *Cook* 是否是我们所关心的方法。
2.  一点都不太能自我发现。如果我们有一个像这样有用的包装方法库，我们就不会有一个好的智能感知方法来知道它们是什么。

我可以解决这两个问题，但这样做会让我们进入一个奇怪的区域，我不确定自己是否会感到舒服。但是，尽管如此，以科学的名义…



![wrapper](img/604011fecf0efe14ec5a622f6d3c4bd9.png "wrapped")



## 让我们倒着开始

喜欢流畅的界面，下面是我希望能够使用的语法:

**包装纸。裹(_ 电饭煲。cook). with . logon error()；**

它的语法有点长，但我喜欢它有几个原因:

1.  它清楚地表明了这里正在发生的事情。我们使用包装器来包装方法调用。我们用一个叫做 *LogOnError* 的方法进行包装。
2.  你一直都有智能感知。正确的实现应该是让我用+‘.’键入*然后查看我已经实现的所有可能的包装方法的列表。这使得包装方法集是自发现的。*

我真的很喜欢这个想法，只要改变最后一部分就可以很容易地改变包装的功能。例如，如果我们实现了一个包装方法 *LogAndAbortOnError()，*我们可以很容易地修改代码来使用它。

**包装纸。裹(_ 电饭煲。cook). with . logandabortonerror()；**

如果我们正确地实现了这一点，intellisense 将为我们提供选项。

## 让它如此

在 C#中创建一个流畅的语法通常会涉及到相当多的魔法和巫术。我总是喜欢在开始这样的旅程之前收集我的试剂。

所以拿一只活鸡，一个订书机，一把锋利的刀，我们走吧！

第一步，让我们简化一下。带的*很好，但只是为了心流，我们并不真的需要它。因此，让我们弄清楚如何在没有*的情况下用*实现我们的语法，并在之后添加它。*

**包装纸。裹(_ 电饭煲。厨师)。logon error()；**

首先是简单的方法。

1.  用一个*包装*方法创建一个静态*包装*类，该方法采用一个*动作*并返回一个*动作*。(我们将使用它来将我们传入的任何内容转换成一个*动作*，这样我们就可以在那里使用 Lambda 表达式或任何方法调用。)
2.  创建一个静态扩展方法来操作一个*动作*。称之为*登录错误*。

不算太坏。这里没有太多的魔法。只是用了一个扩展的方法。

但是，我们已经有一个问题了。使用一个普通的旧动作会给我们在智能感知下拉列表中提供太多的选择。这可能会使我们很难知道我们真正的选项是什么，当我们稍后尝试添加带有语法的*时，我们将需要使用从 *Wrap* 方法返回的对象的属性。*

## 让它变得更好

我们可以通过用自定义类型包装*动作*来解决这个问题，我们可以将我们的方法添加到自定义类型中。

不是 *Wrap* 返回一个*动作*，而是返回一个*Wrap ped 动作*。

更好看了。现在当我们加上一个“.”在我们的*结束*调用时，我们只看到*登录错误*作为一个选项。

我们现在可以确定，如果我们为一个 *WrappedAction* 创建一个扩展方法，我们将确保该方法是可自我发现的。之前，通用的*动作*扩展方法可能会使我们的方法出现在我们不希望它出现的地方，并且可能会在*动作*的其他方法中消失。

## 完成它

我们需要做的最后一件事是将*和*相加。

理想情况下，当我们点击“.”在*包装*方法的末尾，我们希望看到将作为选项的*。当我们点击“.”在带有*属性的*的末尾，我们希望看到 *LogOnError* 作为一个选项。*

为了做到这一点，我们需要:

1.  向*wrap action*添加一个带有属性的*。*
2.  让带有属性的*成为新类型( *WrappedActionTarget* )，这样我们就可以为新类型添加扩展方法。*
3.  更改扩展方法以操作新类型。

这是我们最终得到的结果:

现在我们可以使用以下语法:

**包装纸。裹(_ 电饭煲。cook). with . logon error()；**

我们可以将那个 *LogOnError* 方法移到另一个类中，或者在其他地方创建新的扩展方法。我只是把它放在那里，以避免创建另一个类。

## 这真的实用吗？

我不知道。老实说，我一直在尝试创建处理动作的扩展方法，我想出了这种方法来使用它们。

我可以设计一个包装库，里面有不同的方法来包装内置的方法调用。它可以让您指定如何登录配置，然后您将自动获得所有这些常见的东西。

即使它不实用，也很有趣，它展示了*动作*的威力，或者更确切地说，是一般的函数式编程。