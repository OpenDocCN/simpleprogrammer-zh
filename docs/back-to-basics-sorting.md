# 回归基础:排序

> 原文：<https://simpleprogrammer.com/back-to-basics-sorting/>

为什么分类这么难？

我从开发人员那里看到的最常见的误解和挫折之一就是排序。

几乎每个开发人员在他们的开发生涯中都面临着以某种方式对事物列表进行排序的需求。许多开发人员最终都在摸索，从网上寻找一个例子，然后复制那个例子，并不真正知道他们做了什么，也不知道为什么会这样。

如果你属于这一类，或者只是想更好地了解排序是如何工作的，请继续关注，我们会让它变得简单。



![harry-potter-sorting-hat](img/d4f57794006aab46f3dde3b6eb23665f.png "harry-potter-sorting-hat")



## 排序算法？

没有。

对计算机科学很有帮助。你应该对它们是如何工作的有一个基本的概念，但是除非你在集成电路上写一些低级的位代码，否则你不需要了解它们。

让我们把排序算法想象成一个黑盒。你不需要知道算法是什么或者它是如何工作的，你只需要知道如果你给出它需要的两个东西，它会为你排序你的列表。

**不管实现如何，所有排序算法都需要哪两项？**

1.  要排序的事物列表
2.  要调用的方法，用于判断对象 A 是在对象 B 之前还是之后，或者它们是否相同。

这就是你所需要知道的，并交给一个排序算法实现，它会做剩下的事情。

每一种现代编程语言都至少有一种排序算法，每一种都有我上面提到的两个完全相同的输入，一个要排序的列表和一个比较方法。

不管你用的是 C#、Java、Ruby 还是其他什么语言，它们都实现了一个排序算法，都需要那两样东西。这就是他们需要你做的一切。

你肩上的担子卸下来了。

## 第一步:找到排序方法

我会做得比教你如何用每种语言排序更好。我将向你们展示如何在一种语言中进行排序。

不管使用何种语言，做这件事的第一步是找到对事物进行排序的方法。

查看列表或集合对象本身是一个好地方，因为这是放置排序例程最明显的地方。

当我们在 C#中查找[列表](http://msdn.microsoft.com/en-us/library/6sh2ey19.aspx)时，果然我们在那里找到了排序。

哦不！好困惑！它有 3 种排序方法！我该打给哪一个？啊！

不要惊慌。记住我上面说的。尽管您看到 sort 方法有三个签名，但 sort 方法仍然只需要两个东西。

Sort()、Sort(比较< T >)和 Sort(比较者< T > ) 仍然只需要一个列表和一个方法来比较你的两个对象。

我们一会儿会深入探讨这个问题，现在让我们来看看 Java。

如果我们在 Java 中查找 *ArrayList* ，我们找不到排序方法。嘘。他们在想什么。不过没关系，谷歌搜索“Java 排序”会出现*数组、排序*和*集合、排序*。

让我们看看 *Collections.sort* 。

这次我们看到两种排序方法，*排序(List list)*和*排序(List List，Comparator c)* 。

同样，没什么好害怕的，因为我们知道所有排序算法需要我们做的两件事。

## 第二步:找到两件东西

所以如果每种排序方法都需要你做同样的两件事，那么你需要做的就是想办法给它这两件事。

在上面的 C#和 Java 实例中，第一件事(要排序的事物列表)相当明显。在 C#中我们看到 sort 方法在 list 类本身上，所以我们甚至不需要给它传递要排序的东西的列表，它仍然需要它，但它知道在哪里找到它。

在 Java 实例中，两种排序方法的第一个参数都是一个列表。

看到我们做东西有多简单了吗？我们已经完成了 50%。

所以剩下的唯一问题是如何提供比较两个对象的方法。

当我们知道自己在寻找什么时，就更容易找到和理解。

让我们分解每个实例并弄清楚这一点。

如果我们看 C#的 *Sort()* 方法，不看文档，大概能猜到两件事。

1.  要排序的列表就是我们调用排序方法的列表。
2.  列表中的对象提供了比较方法。

首先是显而易见的。第二个不太明显，但是仔细想想，因为这个方法没有参数，所以唯一可能提供这个方法进行比较的是列表中的对象。

如果我们查看 Sort()的[文档](http://msdn.microsoft.com/en-us/library/b0zbh7b6.aspx)，我们会发现这是真的。列表中的对象必须实现 *IComparable* 。 *IComparable* 有一个方法， *CompareTo* ，它获取一个对象并将其与另一个进行比较。如果你在你的对象上实现了这个接口，你可以对它们的列表进行排序。简单。

对于*Sort(Comparison<T>)*，我们很容易推断出，那里传入的一定是比较两个对象的方法，果然如此。如果我们想要使用这个方法，我们只需传入一个类型为*的比较方法< T >* ，其中 T 是我们想要比较的对象的类型。

我们可以看到，*比较< T >* 只是一个方法，它获取你的两个对象，并返回一个 int 来表示哪个更大或者它们是否相等(1 =更大，0 =相等，–1 更小)。

最后的 c#*Sort(I comparer<T>)*只是取了一个实现了*I comparer<T>T3】的对象。果然，*I comparer<T>T5】有一个方法必须实现，比较。该方法与上面的*比较<T>T7】具有相同的签名。***

现在，我们来看看 Java。你会发现这几乎是一回事。

对于 *sort(List list)* ，我们可以很容易地看到要排序的列表是作为参数传入的，但是我们必须再次找到在哪里提供方法来比较我们的两个对象。

既然传不进去，那肯定是……跟我说……在对象上。没错！

原来我们只需要让我们的对象实现 *Comparable* ，然后就可以对它们进行排序。当我们查看 *Comparable* 接口时，我们看到它只有一个方法， *CompareTo(Object o)* ，这个方法只接受另一个对象与我们的对象进行比较，如果我们的对象更大，则返回 1，如果相同，则返回 0，如果我们的对象更小，则返回-1。

现在我们来看 *sort(List list，Comparator c)* 。在这种情况下，我们可以看到比较我们的两个对象的方法被传入，但由于我们不能在 Java 中传递方法，Comparator 只是一个我们可以实现的提供比较方法的接口。

如果我们看一下*比较器*接口，我们看到它有一个我们需要实现*比较(对象 o1，对象 o2)* 的方法。我相信您现在已经猜到该方法应该返回什么了。

所以不管是什么语言，当你在考虑如何使用一个排序算法时，找到它需要的两个东西。列表通常是显而易见的，但是比较的方法几乎总是以三种方式之一实现。

1.  被比较的对象实现的接口。
2.  传入的方法。
3.  传入的实现比较接口的对象。

## 步骤 3:实现方法

在你想出如何将你的列表和你的比较方法传递给排序算法之后，你需要实际编写比较方法。

如果你学会了写一个比较方法，你可以把它用于任何排序算法，因为所有的比较方法都做完全相同的事情。

幸运的是，这也很容易，因为比较方法总是做完全相同的事情。它们接受两个对象，并返回第一个对象是否大于、小于或等于第二个对象。就是这样。

不用担心排序的问题。还记得我跟你说过的排序算法黑盒吗？让排序算法去担心排序，你所要做的就是决定一个给定的项目是否在第二个给定的项目之前，或者它们是否相同，仅此而已。

你能做到吗？

按年龄给人分类？

如果一号人物。年龄>人 2。年龄回报 1

Else if person1。年龄

否则返回 0

伪代码，但是很简单。

## 包装它

如果你能想出在你的语言中可以用什么方法排序，找到如何传入要排序的事物列表并提供比较方法，实现比较方法，那么你就可以排序了！

只要记住不要不知所措，逻辑地思考所有排序方法都需要你做的两件事，你就会发现整个排序过程是多么简单。

你可以成为每个人都询问排序的人，而不是从互联网上复制并粘贴一些排序代码的人，你真的不知道它是如何工作的。

顺便说一下，在 C#中，我建议只使用 LINQ 扩展方法 OrderBy。

很高兴做这样的事情:

人们。OrderBy(p => p.Age)。order by(p = > p . Name)；