# 像忍者一样解析列

> 原文：<https://simpleprogrammer.com/parsing-columns-like-a-ninja/>

这段代码你写过多少次了？：

或者类似的代码。解析一行，然后获取每一列，并将其作为数据存储在对象中，这是很常见的。

一个恼人的问题是，如果你有可选的列，你必须在解析它们之前检查它们是否存在。

你也在重复你的代码来去掉引号，或者你正在做的任何其他预处理。

我知道您可以使用数据驱动的方法来指定列到属性的映射，但是我想要一个技术含量非常低、简单的解决方案。

我最终用我最喜欢的 C#构造之一想出了一个。

## Action <>是解决这类问题的绝佳工具

看看这段代码是否能让你感觉好一点:

可能看起来没什么。这并不是真的减少了代码，但是我们在这里做了一些重要的事情。

*   删除了可选列的显式处理，因为我们现在只填充现有的列。(添加一个新的可选列就像在列表中多添加一行一样简单。)
*   从代码中删除了明确跟踪列号的责任。现在，列表中列的顺序隐含了列号映射。
*   删除了对每一列重复调用 StripQuotes 的隐藏代码重复。
*   将属性到列的映射与它们的分配分开。

最后一点值得多解释一下。为什么我们关心是否已经将属性到列的映射从赋值中分离出来？

答案并不明显，直到您尝试使用相同的代码来处理一组不同的列，或者以不同的顺序处理列。

通过分离映射，我们可以将分配代码传递给一组不同的映射，它仍然可以工作。

这允许我们重用我们在将列分配给属性时拥有的逻辑，而不是为其他列到属性的映射或排序重写它。