# 现代开发者，第 2 部分:设计

> 原文：<https://simpleprogrammer.com/modern-software-design/>

<figure class="alignright is-resized">

![](img/fdccab028642febb856af183ca3e0a91.png)

</figure>

设计系统的架构被认为是软件开发中最重要的部分之一——因此，它通常由团队中最有经验的人来完成，比如架构师和高级开发人员。

架构设计师需要解决几个关键问题:系统将有哪些组件，它们将如何被分割，以及它们将如何相互通信？将使用什么存储或 web 服务器？是否需要更多的支持软件，如缓存或队列？

让我们来看看传统设计是如何完成的，它有什么问题，以及它们是如何被解决以发展成最终成为现代设计的。

## 设计过程

在过去的几十年中，这一过程发生了很大的变化，主要是因为对软件的要求提高了，最低可接受的质量变得更高了，软件运行的规模现在与 25 年前不同了。

目前，系统可以拥有数千万活跃用户，而几十年前，大多数软件都是一次供一个用户使用的，并且没有在线连接。

请记住，设计应该是满足所需标准的最简单的版本。当今软件的所有复杂性——例如分布式软件的数据库由数百台物理机器组成，所有这些机器都相互通信——都是因为一个简单的原因:市场需要它。

添加不需要满足验收标准的东西是软件设计中最大的问题。

以一个小镇的简单送花服务为例。实际上，不可能拥有数百万的活跃周用户——毕竟，我们只是在一个只有几千人的小镇上运营。用分布式数据库或添加缓存层来设计花店可能很有诱惑力，但这是大材小用，很可能超出预算。

现在让我们来看一个鲜花递送业务，它在整个州/国家有 150 家实体店。这是 150 个城市，有些小，有些大。公司很可能会有一个集中的系统(只要各镇管辖范围相同)。

受众可能包括几百万潜在客户。对于这样一个可能的用户群，在负载均衡器后面添加一些 DDos 保护、缓存层和一些服务器是有意义的。

还有其他因素将决定设计，例如，预期的服务时间。每个因素都有一个共同点，那就是对业务有直接影响的因素。

那么为什么人们有时会在架构设计中引入不必要的复杂性呢？首先，每个开发人员都喜欢使用最新的流行语言、工具或库。另一件事是，软件可以作为非软件出售，就像 MongoDB 的情况一样。最后，我们是人，我们会犯错误。不管你有多少经验，在设计系统时，你的首要任务应该是以最小的复杂度满足所有的需求。

## 传统设计

<figure class="alignright is-resized">

![](img/d835742caebff24ebf13d86d1c964fc8.png)

</figure>

在过去，设计相当简单，部分原因是大多数软件的用户基数小，部分原因是缺少许多选项。然而，这并没有让工作变得无足轻重。

平均来说，更新比现在要困难得多，所以过去的错误代价更大。此外，由于当时工作的性质，大多数错误都是在开发过程中很晚才发现的，而不是在设计过程中。

瀑布方法是那个时代的王道。最重要的是，一个阶段(如计划、分析、设计、开发、质量保证等。)必须 100%完成，下一个才能开始。

然而，这一逻辑后来被证明是有缺陷的。瀑布方法的主要问题是极其缓慢的反馈。如果你在你的设计中引入了一个缺陷，你通常只有在剩下 10%到 15%的分配时间时才能发现它。更糟糕的是，它可能已经被实现了，所以架构师和开发人员的时间就被浪费了。

由于设计过程非常正式，通常会产生许多统一建模语言图形式的工件来解释系统中的所有实体、子系统和接口。

随着时间的推移，人们开始注意到减少反馈所需的时间减少了总的开发时间，从而减少了构建软件的成本。因此，除了瀑布方法中涉及的其他[主要问题](https://simpleprogrammer.com/dont-go-chasing-waterfall/)之外，支持短反馈循环的方法是首选。

## 现代设计

如今，像 scrum 这样的敏捷方法和过程框架是首选。尽管被证明不是一个[银弹](https://simpleprogrammer.com/when-scrum-hurts-mob-achitecture/)，因为有大量的问题要处理，它是瀑布模型的全面改进。游戏对于软件的设计有什么不同？

不幸的是，软件需求从来不是一成不变的。它们不断变化。事实是，在系统开始运行之前，没有人知道系统的全部需求。拥有短的反馈循环有助于在早期发现更多的错误，并调整设计和架构以更好地适应它们。

在某种程度上，最初的冲刺是追踪子弹，一个有希望捕捉设计中主要缺陷的基本实现。然而，所有的错误都被发现是极不可能的。

这意味着设计应该足够灵活以允许变化。灵活性的代价是增加复杂性，如上所述，设计的目标是以最少的复杂性满足所有需求。

我们正处于十字路口，通常不清楚该走哪条路。选择灵活还是简单是根据经验发展出来的，并没有一个每次都可以遵循的规则。

除了方法之外，实际的设计在几十年间也发生了变化。在过去，所有的开发都是一次完成的，在构建时没有太多的反馈，因此，软件通常是在一个大块中构建的。这种架构被称为单片。

如今，由于[敏捷](https://simpleprogrammer.com/agilesoftdev)，每件事情都是以小块时间的方式完成的——也就是说，你有冲刺阶段，这是一至六周的时间，在此期间你做一件具体的事情，接收反馈，当反馈被应用时，下一部分的工作就开始了。

这自然会导致软件被分解成小块，每个小块做一件特定的事情。这被称为面向微服务的方法。

这种方法的“营销”将列出用这种方法开发软件的许多好处。然而，它受欢迎的原因是因为软件是一次开发一大块(一到六周)，使用由许多相对较小的独立组件组成的架构感觉很自然。

实际上，管理和监控大量小型服务往往比单个应用程序更麻烦。这并不是说面向微服务的设计不好，但它远不是很多人所说的银弹。

## 设计趋势

<figure class="alignright is-resized">

![](img/350f0781d61f6967568cd9f83b17f299.png)

</figure>

虽然移动平台和网络是两个非常不同的世界，但它们的设计趋势有些相似。在网络繁荣之后，perl 和 PHP 被用来建立网站。没有标准，没有框架，没有工具。谈论任何类型的生态系统都为时过早。那么，接下来发生了什么？

每个人都开始为一切构建定制框架。不用说，大多数框架都是垃圾，99%都被创建它们的人独占使用。然而，其中一些为我们今天拥有的下一代框架和最终的技术生态系统铺平了道路。

开源和合作蓬勃发展，以至于它成了显示你有多投入的一种主要方式。如今，这是许多公司的期望。

今天，有大量不同的架构，根据软件的具体情况，任何架构都可以工作。不过，我看到的一个趋势是使用大量服务，而不是托管自己的服务。例如，现在有了像关系数据库即服务、电子邮件、队列、键值存储、缓存等服务。

使用服务而不是托管您自己的解决方案的许多优点和缺点超出了本文的范围，但它可能是未来帖子的主题。

今年年初，我在咨询一个教育应用程序，该应用程序将用于学龄前儿童的研讨会。我展示了几个设计，被选中的是使用最多服务的一个。

在这种特殊情况下，项目的寿命预计为两到三年。我们选择了在数据恢复、备份和正常运行时间方面有严格服务级别协议的服务。正如我提到的，该项目的预期寿命长达三年，服务费用为几千美元，建造起来更便宜也更快。

从长远来看，如果有变化，这将花费更多的钱，但由于我们需要推出 1.0 版本并结束工作，这似乎是一个好办法。

## 设计就是寻找平衡

设计的目标是以最少的复杂性满足所有的业务需求。尽管设计过程可能会改变和发展，但它的最终目标是一样的。

设计阶段的错误是不可避免的。因此，反馈循环应该尽可能的短，以便在不浪费团队其他成员时间的情况下修复设计和架构问题。

设计中的变化是不可避免的，不仅仅是因为建筑师犯了错误，还因为人们不确定他们到底需要什么。因此，考虑到这一点，必须在低复杂性和灵活性之间保持平衡。