# 回到基础:内聚和耦合第 2 部分

> 原文:[https://simple programmer . com/back-to-basics-cohesion-and-coupling-part-2/](https://simpleprogrammer.com/back-to-basics-cohesion-and-coupling-part-2/)

这篇文章是我关于内聚和耦合的文章的延续，它是一系列[回归基础](https://simpleprogrammer.com/2010/10/30/getting-back-to-basics-introduction-and-why/)文章的一部分，这些文章审视并质疑软件开发的一些核心原则和实践。

在我的上一篇文章中，我谈到了什么是内聚和耦合，以及它们各自的一些好处。

现在，我想看看内聚和解耦在软件系统上的实际应用。

## 粒度影响内聚性和耦合性

这是对内聚和解耦的主要误解。

内聚和解耦完全是相对于模块的粒度而言的。



![MARBLES](img/6f83a0557a9f09818951738704d55fcd.png "MARBLES")



从现在开始，我不会说类、软件或系统，当提到内聚和耦合时，我会说模块。

看，问题是我们需要能够定义什么是模块，以便确定某个东西是松散耦合的还是高度内聚的。

我给你举个例子。让我们以上面讨论的链表类为例。如果我们在代码中定义一个模块为任何类，那么它是相当解耦的。但是，如果我们将一个模块定义为系统中的任何类或原始类型，我们的链表实现将会突然依赖于许多其他东西。现在，我们在类中声明的所有变量都依赖于数组、字符串类或整数实现。

当我们深入到模块的上一层时，我们会发现更多的依赖关系，这代表了更紧密的耦合。

凝聚力呢？如果你愿意，考虑一下。这是 FizzBuzz 问题的一个实现:

*   打印从 1 到 100 的数字
*   如果这个数能被 3 整除，就打印“Fizz”
*   如果这个数字能被 5 整除，就用“嗡嗡”代替
*   如果数字 3 和 5 是可分的，打印“FizzBuzz”

这是一个简单问题的实现，使用了 3 个程序集和 16 个以上的类。如果我们把一个模块看作是一个类，那么它一点也不内聚，因为应该在一两个方法中的职责分散在 16 个方法中。如果我们认为一个模块是一个程序集，它仍然不是非常内聚。

在这个软件变得有凝聚力之前，我们必须一直放大到模块是一个程序级别，但是在这个级别上，它与它所依赖的各种其他框架非常耦合。

这一部分有两点很重要:

1.  我们如何定义一个模块会影响软件的内聚性和耦合性。
2.  我们用来构建软件的粒度会影响内聚性和耦合性。(这个隐藏在企业 FizzBuzz 示例中。在这种情况下，代码的作者将责任定义为非常非常小的事情。)

总而言之，我们可以从不同层次的放大和缩小来看代码，并确定其耦合性和内聚性。我们也可以将软件构建成不同大小的“乐高积木”,具有相同的效果。

## 当内聚和耦合反向相关时

有了这样的背景，我们终于可以回答是否有可能实现高内聚和松耦合的问题了。

答案是“在某种程度上”

如果我们试图在松散耦合区走得太远，我们会发现我们最终会把责任的定义变得非常非常小，在这一点上我们失去了内聚性的品质。

我将再次挑出[过度使用接口](https://simpleprogrammer.com/2010/11/02/back-to-basics-what-is-an-interface/)来给你举个例子。

考虑一下当我们创建一个接口来“减少耦合”以便我们可以创建单元测试时会发生什么。我们最终降低了内聚性，因为我们的类引用的类(一次跳转)，现在是一个由类实现的接口(两次跳转)。)

现在考虑当我们添加一个依赖注入模块或者仅仅是一个工厂来获得实现时会发生什么。我们曾经简单且高度内聚的实现分散在一个接口上，该接口由一个类实现，我们必须在工厂中查找该类，该工厂包含某种映射文件以将接口映射到实现。(3-4 跳。)

我知道这个概念看起来很奇怪，但是让我看看我是否能用一个真实世界的例子来解释它。

再次考虑高度凝聚的棒球。它已经处于最佳耦合 0。不取决于别的。但是，如果我们愿意，我们可以尝试将其解耦。怎么会？我们必须放大到这样一个点，在这里我们可以认为外部缝线与外壳相耦合，而外壳与内部球相耦合。

我们可以通过拆开棒球来分离它，并设计某种接口，允许外壳和某种基底的不同类型的绑定机制，以防止外壳直接接触内球。

如果我们这样做，我们会把球的碎片弄得到处都是，这将不是很有凝聚力，甚至没有功能。

我们可以用软件做同样的事情。有一点我们已经达到了松耦合和高内聚的最大质量，我们可以尝试以内聚为代价来推动解耦。

## 凝聚力更重要

可能看起来我是在说内聚力比解耦更重要，实际上我也是这样说的。

为什么？

如果您记得紧密内聚和松散耦合的优点，您可能已经意识到大多数优点是相同的，除了紧密内聚给我们增加理解的好处。

我倾向于重视软件的理解和简单性，因为它们在维护和调试中帮助最大。

当我们寻求增加脱钩时，考虑凝聚力是非常重要的。它还可以帮助我们非常清楚地衡量何时去耦最大化。当任何脱钩都将损害凝聚力时，我们就完了。

## 那么依赖注入不好吗？

不，一点也不。依赖注入和其他解耦方法都有它们的位置，但是非常重要的是，我们不要盲目地在每种情况下对每个类使用它们。

当我们考虑使用任何一种框架或模式来分离我们的软件时，我们必须意识到我们在内聚性和可理解性方面所失去的东西。

我在这里再挑一件事，因为我认为它不是很明显。考虑一下消息总线对于将不同的应用程序集成在一起有多好。消息传递系统可以解耦需要相互通信的不同应用程序，使它们高度内聚，非常松散地耦合。

现在，考虑一下应用程序内部的消息总线有多糟糕。我知道这是一个相当流行的解决方案，用于分离事件、命令和应用程序中的其他通信，但是很多时候分离的成本对内聚性和可理解性是一个很大的打击。

不要误解我的意思，有时候内部消息总线对于应用程序来说是一个很好的解决方案，但是在很多情况下，它对你的伤害大于帮助。

## 这都是关于大小合适的乐高积木

[Scott Hanselman](http://www.hanselman.com/blog/) 经常喜欢谈论“大小合适的乐高积木”，我 100%同意他的观点。弄清楚如何在保持内聚性的同时适当地解耦应用程序，就是要弄清楚模块的理想大小。

有时，答案甚至可能是将您的应用程序分成多个应用程序。