# 不是一切都是 80-20，不要盲目遵循帕累托定律

> 原文:[https://simple programmer . com/everything-80-20-don ' t-blindly-follow-paretos-law/](https://simpleprogrammer.com/everything-80-20-dont-blindly-follow-paretos-law/)

有一个关于这个世界的有用观察经常应用于软件开发，叫做[帕累托法则](http://en.wikipedia.org/wiki/Pareto_principle)或帕累托法则。

这个原则表明，在许多情况下，80%的结果来自 20%的原因。

例如，帕累托已经意识到，在他那个时代，意大利 80%的土地被 20%的人口所拥有。

![](img/0a068b2285a4866c00f5b8f7e4290768.png)

从那以后，许多人，包括 Pareto 本人，都将同样的 80-20 法则应用到生活的许多其他领域，从经济学到商业，甚至软件开发。

但是，我发现我们过于依赖帕累托定律了。

## 一般化的问题

我对帕累托定律的最大问题是，它在太多的情况下应用得太频繁了。在许多情况下，尤其是在软件开发中，帕累托定律成为了一个自我实现的预言——你越是寻找帕累托定律，你就越能神奇地找到它。

这并不是说帕累托定律不是真的——当然是真的。如果你去看一看关于事物分布的真实的硬数字，你会发现在你的统计数据中到处都是帕累托定律。但是，与此同时，如果你去寻找数字 13，你会发现这个两位数的数字在所有其他数字中出现的次数惊人。

把不太适合概括的东西强行纳入那些概括是很有诱惑力的。我们多久使用一次短语“总是”和“从不”我们多长时间篡改一点数据，使其符合 80-20 分布？82%已经足够接近 80%了吧？当然，17.5%已经足够接近 20%了。

你不仅可以获取任何数据，通过稍微改变你测量的数据，如果这些数据足够接近的话，就稍微篡改一下，使其符合帕累托定律，而且你还可以获取任何问题领域，并在不知不觉中轻松找到符合帕累托定律的数据点。你很有可能正在这样做——我们都是。我自己也一直这样做，但大多数时候我并没有意识到。

我发现自己滔滔不绝地对涉及帕累托定律的数据进行归纳，却没有足够的证据来支持我所说的。假设一些数据符合帕累托定律真的很容易，因为在内心深处，我知道如果有必要，我可以让它符合。

## 透过帕累托有色眼镜看世界

![](img/6dcc92a1cfab0da4151bf33ae488924d.png)

You might think there is no harm in fudging numbers a bit and finding more and more places to apply Pareto's law. But, looking at the world and blindly assuming all data falls into a distribution of 20 percent of the causes being responsible for 80 percent of the effects, is like walking around with blinders on your eyes—you are only seeing part of reality and even the reality you are seeing tends to be a bit distorted.

同样，这并不意味着帕累托定律在大部分时间里是不正确的，但这意味着当你只是假设任何看似遵守该定律的数据都将遵守该定律，或者更糟的是，所有数据都必须遵守该定律时，你就严重限制了你的视角，将你的选择限制在那些已经符合你先入为主的理想的范围内。

有时候真希望自己从来没有听说过帕累托定律，这样就不会受制于这种偏见。

让我给你举一个更具体的例子。

假设您盲目地假设您的应用程序的 80%的性能瓶颈来自于您的 20%的代码。在这种情况下，你可能是对的，但也可能是错的。您的代码中有一些部分对应用程序的性能有或多或少的贡献，这是完全可行的。也很可能存在一些严重影响应用程序性能的瓶颈或代码部分。但是，如果您假设比率为 80-20，您可能会花费过多的时间来寻找不存在的神奇的 20%,而不是应用更实用的方法来寻找实际的性能问题，然后按照影响的顺序修复它们。

这同样适用于 bug 或测试。如果我们盲目地假设 20%的代码产生了 80%的错误，或者 20%的测试测试了 80%的系统，我们就软件如何工作得出了相当大的结论，这些结论可能正确，也可能不正确。当你修复了由 20%的代码产生的 80%的错误，会发生什么？现在一段新代码会神奇地产生 80%的错误吗？如果你的 20%的测试用例测试你的 80%的代码，你就不能创建那些测试用例吗？为什么再创造 80%只测试另外 20%呢？如果你遵循了这个建议，那么你不会遇到 100%的测试测试了 80%的代码的情况吗？

问题是，当你开始应用并假设帕累托定律盲目适用时，你就开始对数据做出各种不正确的假设，只看到你所期望的。

## 那么，帕累托错了吗？

简而言之，不。他没有错。帕累托原理是一个东西。一般来说，在许多情况下，观察到少量的原因导致了大部分的结果是很有用的。

但是，在任何地方都应用这种模式是没有用的。对数据的观察应该引导结论，而不是相反。

我发现提出这样一个问题更有用，尤其是在软件开发中，“有没有可能找到一件会产生巨大效果的小事？”

关于这个主题的一本好书是《4 小时厨师》。虽然我并不总是同意 Tim Ferris 的观点，但他绝对是少花钱多办事的大师，并且经常谈论最小有效剂量之类的概念。

换句话说，在特定的情况下，我能找到一件我能做的小事，或者我能做出的改变，让我的钱产生最大的回报吗？

有时候答案其实是“不”，有时候无论我们怎么努力，就是找不到影响大多数的少数。有时候，bug 确实均匀地分布在整个系统中。有时候团队成员的贡献是相当平等的。一个团队成员并不总是对 80%的结果负责。

让我们不要忘记协同作用。基本上就是 1 + 1 等于 3 或更大。有时候，事物的组合构成了整体，把部分分离出来会大大降低功能。

例如:鸡蛋、糖、面粉和黄油都可以用来做蛋糕，你可以说 80%的“凝固感”来自 20%的配料，但如果你忽略其中一种配料，你会很快发现它们 100%都是必要的，甚至没有意义去试图找出哪种配料是最重要的，因为单独每种配料的功能都不同于它们加在一起的功能。

在软件开发中尤其如此。通常在复杂的系统中，系统不同组件之间的各种交互结合在一起，形成了一个特定的性能剖面或 bug 分布。在许多情况下，寻找神奇的 20%就像说鸡蛋是蛋糕“凝固”的 80%的原因一样徒劳。