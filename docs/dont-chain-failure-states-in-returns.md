# 不要在退货中链接失败状态

> 原文:[https://simple programmer . com/don-chain-failure-States-in-returns/](https://simpleprogrammer.com/dont-chain-failure-states-in-returns/)

我最初开始写这篇文章的时候，以为我知道我将要演示的问题的答案。

让我惊讶的是，try catch 解决方案似乎比我最初的解决方案要干净得多。

## 不干净的代码

我在这里使用了一个简短的例子，所以重构可能不会像你所需要的那样跳出来，但是无论如何，让我们尽可能干净地重构它。(这来自一个更大的例子，其中重构是必须的。)

## 重构 1:返回布尔值

我们将每个循环分解成它自己的方法，并将每行和每行中的每列的处理分离到它自己的方法中。一个好的重构让事情变得更加清晰。

请注意新方法的 bool 返回类型，以及如果结果为 false，则提前返回的特殊处理。大多数人在重构第一个例子时(包括我自己)忘记了第一个例子打破了两个循环，并提前返回。

如果你不考虑这一点，你的行为就会不一样。当你重构时，你的行为最好不要与众不同。

这就是问题的症结所在。返回布尔是不好的。我们的方法返回 bool 没有意义。布尔是什么意思？我们碰巧知道它意味着成功或失败，但下一个读者会吗？这似乎很不合适，看看处理返回类型的详细程度。

## 重构 2:存储错误状态

下一个重构就是这篇文章的标题。我打算在这篇文章中建议你不要返回布尔错误状态，而是将错误状态作为你的类的一部分。我仍然认为这是一个体面的解决方案。

我们在这里所做的是存储一些关于对象的状态信息，而不是将结果代码链接到方法调用中。这是一个巨大的进步，因为我们的意思更加明确，我们的对象保持着自己的状态。

它仍然非常冗长。为什么我们要到处检查致命错误？似乎我们很可能会忘记。

尽管如此，还是比返回布尔值好得多。如果你在一个类中，不要害怕在内部操纵该类的状态。很多时候，你可以通过简单地使数据成为类的一部分来消除传递给类中私有方法的返回值和参数。

所以，冗长仍然困扰着我。所以，我试着这样做:

### 重构 3:异常处理程序流控制

这出奇的干净。请注意，我们实际上不必在循环中放入 if 条件来检查我们是否应该提前返回？相反，如果抛出异常，流将立即跳转到 catch 块，我们将在那里记录错误消息。

我对使用异常处理作为流程控制机制有点不舒服，但是考虑到:

1.  当遇到错误时，我们完全中止程序的正常流程(跳出两个循环)。
2.  它是如此的干净和清晰。

我认为这实际上是我的首选解决方案。我通常不会在我可以合理地检测到失败的情况下使用异常，但是我可能不得不重新考虑这个观点。