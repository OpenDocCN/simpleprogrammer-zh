# 代码的目的

> 原文：<https://simpleprogrammer.com/there-are-only-two-roles-of-code/>

所有代码都可以分为两种不同的角色；做工作的代码(算法)和协调工作的代码(协调器)。

引入代码库的真正复杂性通常与将这两种角色组合在一起的类的创建直接相关。

我自己也有负罪感。我会说我写的 90%的代码都没有很好地将我的类分成算法和协调器。

## 更清楚地定义事物

在我深入解释为什么我们应该把我们的代码划分成清晰的算法类或协调类之前，我想花一点时间来更好地定义我所说的算法和协调类。

我们大多数人都熟悉计算机科学中的常见算法，比如 T2 的冒泡排序算法和 T4 的二分搜索法算法，但是我们并没有意识到所有有用的代码都包含了算法。

我这么说的意思是，有一套清晰明确的指令或步骤，通过这些指令或步骤可以解决一些问题或完成一些工作。这组步骤不需要外部依赖，它只对数据起作用，就像冒泡排序不关心它排序的是什么。

花点时间想想这个。我不得不反复检查自己几次，以确保这个结论是正确的，因为它是如此深刻。

它意义深远，因为它意味着我们编写的所有代码本质上都是可测试的、可证明的，并且只要我们能找到表达它的方式，就有可能像普通的排序算法一样不依赖于其他算法。 

我们程序中剩下的(如果我们把算法提取出来)只是胶水。

把它想象成一台电脑。计算机电子学有两个作用:做功和把做功的材料结合在一起。如果去掉 CPU、内存和所有其他实际执行某种工作的组件，就只剩下协调器了。将系统中的组件连接在一起的电线和总线。

## 为什么把代码分成算法和协调器很重要。

现在我们知道了代码可以分为两大类，下一个问题当然是为什么？我们能做到吗？

让我们先解决为什么。

将算法代码从任何协调代码中分离出来的最大好处是，它允许算法代码没有依赖性。(几乎所有的依赖。)

一旦你释放了这种算法代码的依赖性，你会发现代码会立即发生 3 件事:

1.  单元测试变得更加容易
2.  它变得更加可重复使用
3.  它的复杂性降低了

很久以前，在 mocks 被广泛使用和 IoC 容器很少被使用之前，TDD 是很难的。真的很难！

我记得当我第一次站在街角宣称所有的代码都应该是 100%代码覆盖率的 TDD。当时我觉得很疯狂，因为真的没有任何模仿框架，也没有 IoC 容器，所以如果你想使用 TDD 方法编写所有代码，你实际上必须分离出你的算法。如果你想真正地对它们进行单元测试，你必须编写具有最小依赖的类。

然后事情变得越来越容易。许多开发人员开始意识到 TDD 如此困难的原因是因为在现实世界中，我们通常编写具有许多依赖性的代码。依赖的问题在于我们需要一种方法来创建它们的假版本。模仿依赖的想法变得如此流行，以至于整个架构都是基于这一想法，IoC 容器也应运而生。



![MP900175522](img/f23a66f13e37aa38b043b6cbf125491b.png "MP900175522")

[](https://simpleprogrammer.com/wp-content/uploads/2012/10/mp900175522.jpg)我们，作为一个开发社区，本质上扫除了地毯下困难的单元测试的碎屑。随着优秀代码的编写，TDD 和单元测试变得无处不在，但是 TDD 最重要的价值之一被遗忘了，算法代码与协调代码的强制分离。

TDD 变得更容易了，但这仅仅是因为我们找到了一种方法来解决依赖关系干扰我们的类隔离的问题，这种方法使模仿和伪造依赖关系变得不那么痛苦，而不是消除它们。

## 有更好的办法！

我们仍然可以解决这个问题，但我们必须齐心协力。目前阻力最小的方法是使用一个 IoC 容器，编写充满模拟的单元测试，每当你对一段代码进行除了最琐碎的重构之外的所有操作时，这些测试就会中断。

让我给你看一个非常简单的例子，但我认为这个例子清楚地说明了如何重构代码，以消除依赖性并清晰地分离出逻辑。

看看这个简化的计算器类:

该类执行简单的加法计算，并将结果存储在存储服务中，同时跟踪加法会话。

这不是非常复杂的代码，但它不仅仅是一个算法。这里的 Calculator 类需要依赖于存储服务。

但是可以重写这段代码，将逻辑提取到另一个没有依赖关系的计算器类和一个实际上没有逻辑的协调器类中。

现在您可以看到，BasicCalculator 类没有外部依赖性，因此可以很容易地进行单元测试。判断它在做什么也容易得多，因为它包含所有真正的逻辑，而 Calculator 类现在只是一个协调器，协调两个类之间的调用。

这当然是一个非常基本的例子，但它不是人为的。我这样说的意思是，尽管这个例子非常简单，但我并没有特意创建这段代码，以便我可以轻松地将逻辑提取到算法类中。

## 分手建议

我发现，如果你专注于 [**消除模仿**](https://simpleprogrammer.com/2011/01/26/back-to-basics-mock-eliminating-patterns/) **或者甚至只是抱着不在代码中使用模仿的心态，你就可以从一开始就编写出清晰地将算法与协调分开的代码。**

我自己仍在努力掌握这项技能，因为这很难做到，但我相信对那些能做到的人来说，回报是非常高的。在我能够将算法与协调分开的代码中，我看到了更好的设计，更易于维护和理解。

在明年的[温暖鳄鱼大会](http://warmcroc.danielfrost.dk/JohnSon.aspx)上，我会谈论并展示更多的方法。