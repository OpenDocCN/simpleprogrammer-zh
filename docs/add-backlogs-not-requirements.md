# 添加积压工作，而不是需求

> 原文：<https://simpleprogrammer.com/add-backlogs-not-requirements/>

我谈到了如何[移动终点线](https://simpleprogrammer.com/2010/03/17/moving-the-finish-line/)是对 Scrum 团队最具破坏性的事情之一，但是我想谈谈同一问题的另一种变化，即进展中的 backlog 项目的范围蔓延。



![sbLookAtLongList](img/f857b3ec11a694f0f785d67ab77bdc48.png "sbLookAtLongList")



## 应对变化

敏捷就是对变化做出反应。不要误解我的意思，我并不是说你应该在处理待办事项之前先明确你的需求。

敏捷也是关于迭代开发的。我们拿起一个东西，大致了解我们想要构建什么，构建它，然后迭代它，随着我们的进展和找出我们真正想要的东西，使它变得更好。

我今天要解决的具体问题是，知道什么时候允许改变，以及以什么样的分辨率迭代。

我认为这些都是非常重要的想法，需要理解它们才能在敏捷软件开发中获得真正的成功。

#### 变化

对一些人来说，敏捷意味着我们允许在任何时间点进行改变。我认为这种观点有点太极端了。敏捷过程中的某些点是受欢迎的，这取决于过程。

Scrum 欢迎团队致力于冲刺阶段的改变。此后，在冲刺阶段对工作范围的改变是有害的。

看板和[看板就像](https://simpleprogrammer.com/2010/04/28/the-kanbandand-guide/)方法一样，一直拥抱变化，直到积压工作正在进行。在这一点上，对 backlog 的范围或焦点的重大改变带来的危害大于它提供的商业价值。(一般而言)

定义什么样的变化也很重要。

变化的种类极大地影响着它们是有害还是有益。在 backlog 的开发过程中改变屏幕布局通常没什么大不了的。改变屏幕通常的功能。当 backlog 已经在进行中时，添加重要功能的更改也是有害的。

稍后我会谈到这其中的一些原因。现在让我们来看看…

#### 迭代分辨率

对于迭代的含义以及它在敏捷软件开发中的价值有一个普遍的误解。

许多敏捷实践者认为迭代只适用于软件包本身，迭代意味着添加特性。

这个分辨率太大了。**如果你的软件的最小迭代是一个完整的特性，你很可能有** [**fatlogs**](https://simpleprogrammer.com/2010/01/26/scrum-backlogs-that-cover-too-much-and-are-not-thinly-sliced-enough-and-have-spreadsheets-attached-and-have-non-specific-things-like-fix-everything-on-this-page/) **，你就要遇到麻烦了。**

在特性完全演化之前，您可能不会将它们交付给客户，但是如果您试图在一个 sprint 或 cycle 中完成特性的演化，您可能会咬下太多东西，错过迭代的真正价值。

就像你的软件应该通过添加功能来迭代一样，功能本身也应该通过添加功能来迭代。

把你的软件想象成一棵树，把特性想象成树枝。如果你要观察那棵树的生长，如果整根完整的树枝开始在树上到处冒出来，那将是非常奇怪的。

更自然的是树枝本身从小树桩长成大树枝，甚至可能有自己的分支。

## 把它绑回去

假定一个 backlog 已经在进行中，并且您已经很好地理解了在您的过程中什么时候应该允许变更，以及应该发生什么样的解决方案迭代，那么为什么向那个 backlog 添加新的需求是一个坏主意就应该开始变得明显了。

如果您在处理现有的 backlog 并向其添加新的需求，您将在错误的点引入变更，并且可能试图“噗”地将分支扩展到您的软件树上，而不是真正地迭代。

添加一个新的 backlog，作为现有特性的迭代，比尝试在已经进行的工作中添加新的需求要好得多。

但是为什么呢？

好吧，希望我们对变更和迭代解决的讨论已经给了你一些为什么的想法，但是这个问题还有更深的层次。我们来讨论其中的一些。

**心理学**

软件开发中有很大一部分心理因素。我们倾向于被成就感和“工作做得很好”的感觉所激励我们往往会因为目标的改变而失去动力，感觉工作永远不会真正完成。

我举个简单的例子。想象一下，你告诉你的孩子，他们今天的家务是整理床铺。

他们去做了，回来告诉你已经做好了，然后让你检查。当你检查的时候，你看到床已经铺好了，但是你说“地板也需要收拾好。”

所以他们去做那件事，这一次花了一点时间，因为他们已经失去了一些动力，但他们完成后再次回到你身边，你看到地板现在已经被清理干净了，但这一次你说“地板需要用吸尘器打扫”

在这种情况下，尽管每个请求都是合理的，但是在原始任务的基础上构建请求会降低个人的动力，剥夺他们的成就感。

当你在软件开发中这样做的时候，会发生类似的事情。你也失去了团队的信任，因为团队开始认为当企业说 X 时，他们真的会想要 X + Y + Z。团队开始工作得更慢，因为这其实并不重要。您不想在这种模式下操作！很不好！

不要让进化取代它的位置

如果你试图跨越一条河，你要么会被淋湿，要么会成功。如果河水很大，你多半会被淋湿。

从一块石头跳到另一块石头，直到你完全过河，这要好得多。

向进展中的待办事项列表添加需求就像是一次大的飞跃。通过添加另一个 backlog 来使你更接近目标，你允许当前的 backlog 成为一个步骤，而新的 backlog 成为下一个步骤。

对一个进行中的待办事项列表的变更是否代表了一个新的需求，这是一个判断的问题，它应该是一个新的待办事项列表。尽管我宁愿做新的积压工作，也不愿增加需求。我通常说，如果它将显著增加范围，它应该是一个新的 backlog。不管怎样，这项工作都要完成，所以为什么不把你的…

**估算更准确**

没有什么比范围蔓延更能抹杀历史估计了。如果你想要准确的数据，就不要添加未说明的工作。将新的需求挤压到正在进行的积压工作中会增加您的历史数据的工作量，而这些工作量并没有被正确地考虑。

对工作进行分类和说明要比把它放在一个地方好得多，当你试图分析你的数据时，你将没有办法把它提取出来。

当被分配到不断扩大的积压工作中的开发人员为了完成工作而开始匆忙工作时，也要考虑质量的损失，因为他们感觉他们将被与他们完成的积压工作进行比较，并且添加到现有积压工作中的工作将不会被计算在度量中。

不要忘记这里的优先级。如果你把一个需求附加到一个正在进行的待办事项中，你就不能优先处理这个工作。您可能会以延迟其他积压工作中优先级更高的工作为代价来添加该需求。将新的需求放入待办事项列表中，这样你就可以正确地对其进行优先级排序。

## 离别赠言

如果你是一个产品经理，产品所有者，或者商业人士阅读这篇文章，试一试吧。你会惊讶地发现，如果下一次你和他们一起处理积压工作，并意识到需要考虑 X 和 Y，你会宣布你将创建两个以上的积压工作，而不是马上处理，你的团队会变得多么快乐和富有成效。

如果你是敏捷团队的开发人员，你可能甚至没有意识到这个问题可能会削弱你的动力。您可能没有能力做太多，但是您总是可以建议新的需求是一个新的 backlog。