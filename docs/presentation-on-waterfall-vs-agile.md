# 瀑布与敏捷的演示

> 原文:[https://simple programmer . com/presentation-on-fault-vs-agile/](https://simpleprogrammer.com/presentation-on-waterfall-vs-agile/)

我最近做了一个关于[瀑布 vs 敏捷](http://prezi.com/chsbefgx55le/)的简短的 [Prezi](https://simpleprogrammer.com/2010/03/15/powerpoint-killer-prezi/) 演示。

在这样做的时候，我不得不认真思考为什么我认为瀑布不好。

## 反馈回路

对我来说，这真的回到了一个中心问题，那就是反馈回路的长度。当我们使用[瀑布过程](https://simpleprogrammer.com/2010/04/07/dont-go-chasing-waterfalls-mini-waterfall-vs-agile/)进行软件开发时，客户直到项目结束时才有机会得到反馈。甚至测试都是在项目结束时进行的，所以反馈来得很晚。

敏捷给予瀑布的最大优势是反馈循环的收紧。你越快得到反馈，你就能越快对它做出反应，并且你在错误的方向上花费的时间就越少。

从一个程序员的角度来看，想想在工具出现来帮助我们之前，在我们更了解之前，我们中有多少人曾经写过代码。

花 2 个小时写一堆代码

1.  运行编译器
2.  修复错误
3.  重新编写
4.  重复 2-3，直到所有错误都被修复

那浪费了大量时间。尤其是当我们有一些影响大部分代码的语法错误时。

使用现代的 IDE，我们能够看到语法错误在我们键入它们的第二秒就被突出显示。我们可以开始键入一个方法名，自动完成可以接管并为我们提供建议。编写糟糕的语法是很困难的，因为当我们写出代码时，我们会得到持续和即时的反馈。反馈循环如此紧密，以至于我们甚至不认为编译是一个单独的步骤。甚至有一些 IDE 插件会持续运行任何单元测试，这些单元测试可能会受到你在后台修改代码的影响。

如果现代 IDE 体验是敏捷的，那么瀑布就是打孔卡。



![](img/74b1a248be82a8150a55be40af22fb1d.png "Feedback")



## 取其精华

所以，[这里的](http://prezi.com/chsbefgx55le/)就是我的 [prezi](https://simpleprogrammer.com/2010/03/15/powerpoint-killer-prezi/) 演示。有意见请反馈。请记住，这个演示的目的是作为一个非常基础的初学者指南，解释为什么有人应该选择敏捷而不是瀑布。它不会深入到关于敏捷的非常详细的主题。

此外，在演示结束时，你会注意到我建议采用一些 Scrum 的过程和 XP 最佳实践，并使用这些指导原则来运行看板。我目前认为这是敏捷所能提供的最佳组合。