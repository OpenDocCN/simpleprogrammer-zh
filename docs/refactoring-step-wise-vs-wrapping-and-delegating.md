# 逐步重构静态方法与包装和委托

> 原文：<https://simpleprogrammer.com/refactoring-step-wise-vs-wrapping-and-delegating/>

在使用遗留代码的过程中，我经常遇到不得不重构包含静态方法或者完全是静态方法的类的问题。

我之前讲过[重构助手类](https://simpleprogrammer.com/2010/04/14/how-to-refactor-the-helper-class/)，但这次略有不同。

在这种情况下，我想谈谈你想保留的重构类，但有全部或许多静态成员。一个很好的例子是某种从数据库返回数据的服务类。

这种类是否真的是某种帮助类并不总是很清楚。这有点需要判断。如果你找到了一个助手类，不要把它留在那里。

所以，基本上如果你已经决定了你正在使用的类将会保留，但是它有静态方法，你需要去掉它们，因为你正在做依赖注入或者模仿，继续读下去。

## 定义两种方法

我所说的逐步重构是什么意思？

下面是第一种方法的基本轮廓:

1.  使你需要的方法成为非静态的，非静态的。
2.  添加一个只有这一个方法的接口。
3.  实现接口。
4.  请更改对该方法的引用，改为使用接口。

我们来看一个例子:

如果我们对 *GetLostOrders* 方法感兴趣，我们可以应用步骤 1-3 来获得:

现在，我们可以在代码中为这一个方法修改引用。

现在让我们看看第二项技术，包装和委托。下面是包装和委托方法的概要:

1.  创建一个包装类，用于包装静态类调用。
2.  将静态类中的所有方法实现为包装类中的非静态方法。每个方法只是委托给静态类中的静态方法。
3.  创建一个包含所有方法的接口。
4.  让包装类实现接口。

下面是这样做的一个例子，给出了与第一个例子相同的原始代码:

对 *LostOrderService* 的引用将像第一个例子一样被重构，所以我在这里不包括它。

你可以在这个例子中看到，我们没有触及 *LostOrderService* 本身。除了您可能想在类上放置一个过时的属性来告诉用户不要使用它，而是使用包装类。

## 哪个更 bettah？

我过去倾向于使用包装和委托方法，但是我开始认为分步方法更好，原因如下。

*   对于后来使用该类的人来说，分步方法更为明显。当你包装和委托时，必须有人知道有一个包装类。对于逐步实施的方法，别无选择。
*   使用分步方法，您实际上正在摆脱[坏的和邪恶的静态方法](https://simpleprogrammer.com/2010/01/29/static-methods-will-shock-you/)。当你包装和委托时，你仍然把它们留在那里，只是把它们藏在包装器后面。

对我来说，包装方法更像是我在处理事情，而不是清理它们。我也觉得有人可以看到我开始的东西，并从那里一步一步地捡起来。在使用包装方法的情况下，这种混乱可能永远不会得到清理，因为有一个解决方法。

## 包装和委托的亮点

有一个地方，包装和代表赢得轻而易举。

如果您不能控制静态类或静态调用的源代码，您就不能使用分步方法。

当您在代码中处理对无法更改的外部库的静态引用时，包装和委托方法是一个救命稻草。您可以简单地包装外部库调用，而是在代码中引用包装器。现在你可以对代码进行单元测试了。

任何时候你使用一个外部库，你都应该考虑用某种保护性的包装来包装它。你永远不知道什么时候你可能想要替换它或升级库。您不希望在所有代码中寻找引用。

因此，尽管两种方法都可行，但如果我可以访问静态类的源代码，我更喜欢使用分步方法。

你怎么想呢?你有其他的解决方法吗？